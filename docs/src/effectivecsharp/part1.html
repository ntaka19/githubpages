
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Part 1 &#8212; Home 1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/thebelab.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/thebelab-helper.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.0/dist/embed-amd.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Excel Tips" href="../excel/index.html" />
    <link rel="prev" title="Effective C Sharp #6.0, #7.0 まとめ" href="index.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="part-1">
<h1>Part 1<a class="headerlink" href="#part-1" title="Permalink to this headline">¶</a></h1>
<p>番号は、本書の「項目」に対応している。
ここではそれらの補足とサマリーを記述しておく。</p>
<ol class="arabic">
<li><p>ローカル変数の型をなるべく暗黙的に指定すること：</p>
<ul>
<li><p>var は
動的型付けではない。あくまでも型推論が行われていて暗黙的に静的型付けされている。</p></li>
<li><p>型を明記することで、意図しない結果を及ぼす可能性が出てくる。</p></li>
<li><p>var
を用いてわかりにくくなるケースがあるが、これは変数名をわかりやすくすることで回避することも可能。</p></li>
<li><p>しかし開発者からすると、コンパイラが決定した型がなんなのかが分からないという問題点がある。</p></li>
<li><p>一方で、場合によっては開発者よりもコンパイラのほうが変数に最適な型を選びだしてくれる。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Calling</span> <span class="n">IEnumerable</span><span class="o">.</span><span class="n">Where</span> <span class="n">instead</span> <span class="n">of</span> <span class="n">IQueryable</span><span class="o">.</span><span class="n">Where</span>
</pre></div>
</div>
<p>派生元（基底クラス）をあえて記述しているため、コンパイルは通るが、パフォーマンスが著しく落ちる場合がある。IQueryableを使うと効率的な計算が可能。上記の例のように適切なクエリツリーが作成されるなど。（特にデータがリモートサーバー上にある場合有効）全部リモートから返されると大変。</p>
</li>
<li><p>開発者にとってコードを理解するための型の宣言が必要にならないのであれば、ローカル変数をvarとして宣言するのが最善。</p></li>
</ul>
</li>
<li><p>const よりもreadonlyを使用すること。</p>
<ul>
<li><p>コンパイル時定数（const)：パフォーマンスが要求される場面で、かつ低数値が将来のリリースにわたって変更されない場合のみに利用する。コンパイル時にMSILにコードが変更される。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="n">const</span> <span class="nb">int</span> <span class="n">Millennium</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">;</span>
</pre></div>
</div>
<p>とした場合、</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="p">(</span><span class="n">myDateTime</span><span class="o">.</span><span class="n">Year</span> <span class="o">==</span> <span class="n">Millennium</span><span class="p">)</span>
</pre></div>
</div>
<p>がコンパイルしてMSILにした時点で、</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="p">(</span><span class="n">myDateTime</span><span class="o">.</span><span class="n">Year</span> <span class="o">==</span> <span class="mi">2000</span><span class="p">)</span>
</pre></div>
</div>
<p>と同等なものになる。
整数型、浮動小数型、列挙型、文字列型しかできない。
さらたに、プリミティブ型であってもコンパイル時定数をnew
で初期化することはできない。</p>
</li>
<li><p>　実行時定数(readonly)：こちらをなるべく使用したほうがよい。コンパイル時定数は若干早いけど柔軟性の意味でデメリットがある。メソッド内では定義できない。
すべての型で可能。 readonlyの値が実行時に解決される。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="k">class</span> <span class="nc">UsefulValues</span><span class="p">{</span>
    <span class="n">public</span> <span class="n">static</span> <span class="n">readonly</span> <span class="nb">int</span> <span class="n">StartValue</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="n">public</span> <span class="n">const</span> <span class="nb">int</span> <span class="n">EndValue</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>がInfrastructureというアセンブリに存在していたとする。これをApplicationのアセンブリから参照し、コンパイルした。
続いて、</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="k">class</span> <span class="nc">UsefulValues</span><span class="p">{</span>
    <span class="n">public</span> <span class="n">static</span> <span class="n">readonly</span> <span class="nb">int</span> <span class="n">StartValue</span> <span class="o">=</span> <span class="mi">105</span><span class="p">;</span>
    <span class="n">public</span> <span class="n">const</span> <span class="nb">int</span> <span class="n">EndValue</span> <span class="o">=</span> <span class="mi">120</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>と変更したとする。Infrastructureのアセンブリをビルドしても、この場合、Applicationのアセンブリをビルドしない限り、Application側ではEndValue
= 10のまま計算してしまう。</p>
<p class="rubric" id="const-readonly">const, readonly</p>
<p>コンパイル時定数と、実行時定数がある。</p>
<p>一般的に実行時定数を用いほうが良いとされている。</p>
<ul class="simple">
<li><p>コンパイル時定数(const)：パフォーマンスが要求される場面で、かつ低数値が将来のリリースにわたって変更されない場合で利用する。（暗黙的にstaticになっている）</p></li>
<li><p>実行時定数(readonly)：実行時に評価される。”readonlyは実行時に値が決定するので、必ずしも同じ値になるとは限らない。つまり、デフォルトではstaticとして宣言されていないのでインスタンスの中にある変数の一つであると見なすことができる。”
インスタンスごとに異なる値を持つことができる。</p></li>
<li><p>static readonly:
“定数値が必要だが、その値の型がconst宣言では使用できない場合、またはその値をコンパイル時に計算できない場合はstatic
readonlyフィールド。 Effective
C#では、バージョニング問題の観点からconstよりもstatic
readonlyの使用が推奨されています”</p></li>
</ul>
<p>（参考：<a class="reference external" href="https://qiita.com/4_mio_11/items/203c88eb5299e4a45f31">https://qiita.com/4_mio_11/items/203c88eb5299e4a45f31</a>）</p>
</li>
</ul>
</li>
<li><p>キャストにはisまたはasを利用すること。 簡単に言うと、</p>
<ol class="arabic simple">
<li><p>変換できないときの挙動の違い。as演算子の場合はnull.キャストの場合はexception.</p></li>
</ol>
<p>書籍の内容：</p>
<ul>
<li><p>強い型付けとはコードおける方の不一致をコンパイラが見つけてくれるということ。しかし場合によっては実行時の型チェックが避けられないケースがある。as演算子を使用する方法とcastを使用して開発者の意思をコンパイラに強制させる方法がある。</p></li>
<li><p>むやみにキャストするよりもas演算子のほうが安全で、実行時の効率も優れるためこちらを利用したほうがよい。使えるときは使う。</p></li>
<li><p>try catchを避けることができるため、よい。overheadの意味で。</p></li>
<li><p>一番の違い：asやisはユーザー定義の変換をまったく行わない。実行時の型をチェックする。キャストは指定の方への変換演算子を利用できる。</p></li>
<li><p>as
演算子はボックス化された値型をボックス化解除されたnull許容型へと変換する場合、新しい型を作成する。</p></li>
<li><p>キャストを使用すると、nullは任意の参照型へとキャストできるが、as演算子の場合はnull参照に対して、nullが返される。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">object</span> <span class="n">o</span> <span class="o">=</span> <span class="n">Factory</span><span class="o">.</span><span class="n">GetObject</span><span class="p">();</span>
<span class="n">MyType</span> <span class="n">t</span> <span class="o">=</span> <span class="n">o</span> <span class="k">as</span> <span class="n">MyType</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="n">t</span><span class="o">!=</span><span class="n">null</span><span class="p">){</span>
<span class="o">...</span>
<span class="p">}</span>
<span class="k">else</span><span class="p">{</span>
<span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>キャストを使うとnullチェックも必要になってくる。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>object o = Factory.GetObject();
try {
    MyType t;
    t = (MyType)o;
}
catch (InValidCastException){
    //処理の失敗を通知する。
}
</pre></div>
</div>
</li>
<li><p>as とcastの違いは、ユーザー定義の変換の違いにある。as
やisは変換対象となっている実行時の型はチェックするが、それ以外はボックス化を除き、他の処理は行わない。
特定のオブジェクトが指定の型ではないか、指定のかたから派生した型ではない場合に変換に失敗する。</p></li>
<li><p>castは指定の型への変換演算子を利用できる。</p></li>
<li><p>　ユーザー定義型にも問題が出てくる。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="k">class</span> <span class="nc">SecondType</span><span class="p">{</span>
    <span class="n">private</span> <span class="n">MyType</span> <span class="n">_value</span><span class="p">;</span>

    <span class="o">//</span><span class="n">Convert</span> <span class="kn">from</span> <span class="nn">SecondType</span> <span class="n">to</span> <span class="n">MyType</span>
    <span class="n">public</span> <span class="n">static</span> <span class="n">implicit</span> <span class="n">operator</span> <span class="n">MyType</span><span class="p">(</span><span class="n">SecondType</span> <span class="n">t</span><span class="p">){</span>
        <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">_value</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>これをもとに、</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>//version 1


object o = Factory.GetObject();
//This will fail. type of o is SecondType
MyType t = o as MyType;　//oはMyTypeではない。
if(t!=null){
...
}
else{
...
}

//version 2
object o = Factory.GetObject();
    try {
        MyType t;
        t = (MyType)o;　//Fails. o is not MyType
    }
    catch (InValidCastException){
        //処理の失敗を通知する。
    }
</pre></div>
</div>
<p>はどちらも失敗する。 version
２のキャストは一見ユーザー定義の変換ができるため、うまくいくと考えられるが、実は失敗する。
version2が失敗する理由はコンパイラはコンパイル時におけるoの型を基準とｓてコードを生成するから。コンパイラはoの実行時の型をしらない。
コンパイラからしたら、object型のインスタンスである！</p>
<p>objectからMyTypeに変換するユーザー定義の変換演算子ははない。(MyType)o　のところ
そこで、object型とMyType型をチェックする。ユーザー定義の変換はないため、コンパイラはoの実行時の型がMyTypeかどうかを判定するコードを生成。oはSecondTypeなのでチェックは失敗する。.
つまりコンパイルの順番に沿って考えることが重要。</p>
<p>次のように書けば問題は回避できる。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>//version 3
object o = Factory.GetObject();
SecondType st = o as SecondType;
    try {
        MyType t;
        t = (MyType)o;　// oはMyType
    }
    catch (InValidCastException){
        //処理の失敗を通知する。
    }
</pre></div>
</div>
<p>つまりは、ユーザー定義の変換演算子はオブジェクトのコンパイル時における型のみに対して作用する。ランタイムの型に作用するものではない。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">MyType</span><span class="p">)</span> <span class="n">st</span><span class="p">;</span>
</pre></div>
</div>
<p>の場合はstの宣言次第で挙動が変わる。stがSecondTypeだったら通るが、stがobjectで定義されていたら失敗する。
一方で、</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">st</span> <span class="k">as</span> <span class="n">MyType</span><span class="p">;</span>
</pre></div>
</div>
<p>と書くと、継承関係がないもののユーザー定義の演算子が存在する場合はコンパイルエラーになる。（継承関係があれば通る、それ以外は通らない、という意味で一貫性がある）</p>
</li>
<li><p>どのようにしてasを使うか。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>object o = Factory.GetValue();
int i = o as int; //Will not compile!
</pre></div>
</div>
<p>This is because int is a value type therefore not accepting null
as input. However, the code can be rewritten as follows.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>object o = Factory.GetValue();
var i = o as int?;
if(i!=null) Console.WriteLine(i.Value);
</pre></div>
</div>
</li>
<li><p>Foreach
loopではキャストが行われている。なぜなら値型と参照型の両方に対応しないといけないから。ハードコードすると以下のようになる。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="n">void</span> <span class="n">UsecollectionV2</span><span class="p">(</span><span class="n">IEnumerable</span> <span class="n">theCollection</span><span class="p">){</span>
    <span class="n">IEnumerator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">theCollection</span><span class="o">.</span><span class="n">GetEnumerator</span><span class="p">();</span>
    <span class="k">while</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">MoveNext</span><span class="p">()){</span>
        <span class="n">MyType</span> <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">MyType</span><span class="p">)</span><span class="n">it</span><span class="o">.</span><span class="n">Current</span><span class="p">;</span>
        <span class="n">t</span><span class="o">.</span><span class="n">DoStuff</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
<p>で、結局asは使えるときはいつもつかうべきなのか。<a class="reference external" href="https://stackoverflow.com/questions/4926677/c-sharp-as-cast-vs-classic-cast">Stack overflow: C#
“as” cast vs classic cast
[duplicate]</a></p>
<p>With the “classic” method, if the cast fails, an InvalidCastException
is thrown. With the as method, it results in null, which can be
checked for, and avoid an exception being thrown.</p>
<p>Also, you can only use as with reference types, so if you are
typecasting to a value type, you must still use the “classic” method.</p>
<p>Note:</p>
<p>The as method can only be used for types that can be assigned a null
value. That use to only mean reference types, but when .NET 2.0 came
out, it introduced the concept of a nullable value type. Since these
types can be assigned a null value, they are valid to use with the as
operator.</p>
<p>他のコメント：</p>
<p>Null comparison is MUCH faster than throwing and catching exception.
Exceptions have significant overhead - stack trace must be assembled
etc.</p>
<p>Exceptions should represent an unexpected state, which often doesn’t
represent the situation (which is when as works better).</p>
</li>
<li><p>string.Format()を補間文字列に置き換える.String.Formatは生成される文字が評価、検証されるまでは、その内容が分からないため、ミスを誘発しやすいというデメリットがある。また、引数のインデックスを間違いやすい。
補間文字列は最初に”<span class="math notranslate nohighlight">\(\ \{\}&quot;をおく。\)</span></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Console.WriteLine($@&quot;the ratio of the circumference of a circle to its diameter is {round ? Math.PI.ToString(): Math.PI.ToString(&quot;F2&quot;))}&quot;);
</pre></div>
</div>
</li>
<li><p>カルチャ固有の文字列よりもFormattableStringを使用すること.
これは例えばdoubleの小数点は、”.”を使うが、ヨーロッパは”,”を使う。
FormattableStringを特定のカルチャで文字列に変換してくれる。文字列補間をグローバルに。</p></li>
<li><p>文字列指定のAPIを使用しないこと。なぜなら型の安全性が損なわれるから。そのためにnameofが使えるようになる。
「nameofを使用すると、プロパティの名前を変更した場合、イベントの引数に指定された文字列にも変更が反映される。」これが基本的な用法</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Console</span><span class="o">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">nameof</span><span class="p">(</span><span class="n">System</span><span class="o">.</span><span class="n">Collections</span><span class="o">.</span><span class="n">Generic</span><span class="p">));</span>  <span class="o">//</span> <span class="n">output</span><span class="p">:</span> <span class="n">Generic</span>
<span class="n">Console</span><span class="o">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">nameof</span><span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">));</span>  <span class="o">//</span> <span class="n">output</span><span class="p">:</span> <span class="n">List</span>
<span class="n">Console</span><span class="o">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">nameof</span><span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;.</span><span class="n">Count</span><span class="p">));</span>  <span class="o">//</span> <span class="n">output</span><span class="p">:</span> <span class="n">Count</span>
<span class="n">Console</span><span class="o">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">nameof</span><span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;.</span><span class="n">Add</span><span class="p">));</span>  <span class="o">//</span> <span class="n">output</span><span class="p">:</span> <span class="n">Add</span>

<span class="n">var</span> <span class="n">numbers</span> <span class="o">=</span> <span class="n">new</span> <span class="n">List</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">};</span>
<span class="n">Console</span><span class="o">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">nameof</span><span class="p">(</span><span class="n">numbers</span><span class="p">));</span>  <span class="o">//</span> <span class="n">output</span><span class="p">:</span> <span class="n">numbers</span>
<span class="n">Console</span><span class="o">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">nameof</span><span class="p">(</span><span class="n">numbers</span><span class="o">.</span><span class="n">Count</span><span class="p">));</span>  <span class="o">//</span> <span class="n">output</span><span class="p">:</span> <span class="n">Count</span>
<span class="n">Console</span><span class="o">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">nameof</span><span class="p">(</span><span class="n">numbers</span><span class="o">.</span><span class="n">Add</span><span class="p">));</span>  <span class="o">//</span> <span class="n">output</span><span class="p">:</span> <span class="n">Add</span>
</pre></div>
</div>
<p>保守性の高いコードを使うことができる。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    /// &lt;summary&gt;
/// モデル
/// &lt;/summary&gt;
public class AmountModel
{
    ///&lt;summary&gt;コード&lt;/summary&gt;
    public int Code { get; set; }

    ///&lt;summary&gt;税抜き額&lt;/summary&gt;
    public decimal Amount1 { get; set; }

    ///&lt;summary&gt;税額&lt;/summary&gt;
    public decimal Amount2 { get; set; }
}


public class Test
{
    public void Main()
    {
        // データ作成
        var amountModel = new AmountModel { Code = 1111, Amount1 = 3000m, Amount2 = 300m };

        // 税込み額計算
        var amount = Calculate(amountModel);

        // 結果
        Console.WriteLine($&quot;税込み額:{amount.ToString()}&quot;);

        // 結果出力
        // 税込み額:3300
    }

    /// &lt;summary&gt;
    /// 計算
    /// &lt;/summary&gt;
    /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;
    /// &lt;param name=&quot;obj&quot;&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public decimal Calculate&lt;T&gt;(T obj)
    {
        decimal amount = 0m;

        Type type = typeof(T);
        foreach (PropertyInfo property in type.GetProperties())
        {
            switch (property.Name)
            {
                case &quot;Amount1&quot;:
                case &quot;Amount2&quot;:
                    amount += (decimal)type.GetProperty(property.Name).GetValue(obj, null);
                    break;
                default:
                    break;
            }
        }

        return amount;
    }
}
</pre></div>
</div>
<p>AmountModelのメンバが変わったとする。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="n">public</span> <span class="k">class</span> <span class="nc">AmountModel</span>
<span class="p">{</span>
    <span class="o">///&lt;</span><span class="n">summary</span><span class="o">&gt;</span><span class="n">コード</span><span class="o">&lt;/</span><span class="n">summary</span><span class="o">&gt;</span>
    <span class="n">public</span> <span class="nb">int</span> <span class="n">Code</span> <span class="p">{</span> <span class="n">get</span><span class="p">;</span> <span class="nb">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="o">///&lt;</span><span class="n">summary</span><span class="o">&gt;</span><span class="n">税抜き額</span><span class="o">&lt;/</span><span class="n">summary</span><span class="o">&gt;</span>
    <span class="n">public</span> <span class="n">decimal</span> <span class="n">TaxExcluded</span> <span class="p">{</span> <span class="n">get</span><span class="p">;</span> <span class="nb">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="o">///&lt;</span><span class="n">summary</span><span class="o">&gt;</span><span class="n">税額</span><span class="o">&lt;/</span><span class="n">summary</span><span class="o">&gt;</span>
    <span class="n">public</span> <span class="n">decimal</span> <span class="n">TaxAmount</span> <span class="p">{</span> <span class="n">get</span><span class="p">;</span> <span class="nb">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>この時、次の箇所でエラーは出るので修正可能。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">amountModel</span> <span class="o">=</span> <span class="n">new</span> <span class="n">AmountModel</span> <span class="p">{</span> <span class="n">Code</span> <span class="o">=</span> <span class="mi">1111</span><span class="p">,</span> <span class="n">TaxExcluded</span> <span class="o">=</span> <span class="mi">3000</span><span class="n">m</span><span class="p">,</span> <span class="n">TaxAmount</span> <span class="o">=</span> <span class="mi">300</span><span class="n">m</span> <span class="p">};</span>
</pre></div>
</div>
<p>一方で、Testではエラーが出てこないため(switchにひっかからない）、実行すると税込み額:0が表示される。次のように修正すれば正しくコンパイルエラーになるため、修正できる。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="n">switch</span> <span class="p">(</span><span class="nb">property</span><span class="o">.</span><span class="n">Name</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">case</span> <span class="n">nameof</span><span class="p">(</span><span class="n">AmountModel</span><span class="o">.</span><span class="n">Amount1</span><span class="p">):</span>
    <span class="k">case</span> <span class="n">nameof</span><span class="p">(</span><span class="n">AmountModel</span><span class="o">.</span><span class="n">Amount2</span><span class="p">):</span>
        <span class="n">amount</span> <span class="o">+=</span> <span class="p">(</span><span class="n">decimal</span><span class="p">)</span><span class="nb">type</span><span class="o">.</span><span class="n">GetProperty</span><span class="p">(</span><span class="nb">property</span><span class="o">.</span><span class="n">Name</span><span class="p">)</span><span class="o">.</span><span class="n">GetValue</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">null</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="n">default</span><span class="p">:</span>
        <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>デリゲートを使用してコールバックを表現する: call back
の例：仕事をふって、その間に自分は作業をしている。どうしても必要な時に自分の手を止める。Callbackはサーバーからの応答を非同期的に待機するような場合に使用する。delegateは主にeventに合わせて利用するが、それだけではない。「特定のクラスの間でデータをやり取りする必要があるものの、互いのインタフェースを使用するほどには密に連携させたくない場合」が最善だったりする。</p>
<ul class="simple">
<li><p>Callback関数とは呼び出し先の関数の実行中に実行されるようあらかじめ指定しておく関数。eg.
main
がcallbackを呼び出して、mainは次の処理を行う。その後に、callback関数の処理が終わったら呼び出し戻す。</p></li>
<li><p>イベントハンドラとは、コンピュータプログラムで、特定の出来事（イベント）が発生した時に実行するよう定められた処理のこと。
対象となるイベントの種類や条件と、処理内容をセットで記述する</p></li>
</ul>
</li>
<li><p>イベントの呼び出し時にnull条件演算子を使用すること:
イベントについては、次の手順:</p>
<ol class="arabic simple">
<li><p>必要に応じてイベントを定義。</p></li>
<li><p>このイベントにアタッチされたイベントハンドラを呼び出すだけ。
このことによって、後ろに隠されたマルチキャストデリゲートによって、登録された全てのハンドラが成功する限り呼び出される。</p></li>
</ol>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">private</span> <span class="n">EventHanlder</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span> <span class="n">Updated</span><span class="p">;</span>

<span class="n">public</span> <span class="n">void</span> <span class="n">RaiseUpdates</span><span class="p">(){</span>
    <span class="n">counter</span><span class="o">++</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Updates</span> <span class="o">!=</span> <span class="n">null</span><span class="p">)</span>
        <span class="n">Updated</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">counter</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ここで、Updatedはイベントでありそこにハンドラ登録されている。
上のコードの問題点は、null
checkが通った直後に、イベントが解除された場合、null
参照となってしまう点である。 マルチスレッドの時に問題起きる。</p>
<p>スレッドセーフ にするためには以下を行う。
下のコードでは現在のイベントハンドラを新しいローカル変数handlerに割り当てている。
handlerには、メンバ変数であるイベントUpdatedから参照されている全ての元ハンドラを参照するようなマルチキャストデリゲートが格納される。</p>
<p>イベント割り当て演算子では右辺の浅いコピーが割り当てられる。浅いコピーはアタッチされたイベントハンドラそれぞれに対する参照コピーが含まれる。
別のスレッドでイベントからハンドラが解除されると、登録解除個〇度ではクラスに定義されたイベントフィールドが変更されるが、ローカル変数からはそのハンドラが削除されない。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="n">void</span> <span class="n">RaiseUpdates</span><span class="p">(){</span>
    <span class="n">counter</span><span class="o">++</span><span class="p">;</span>
    <span class="n">var</span> <span class="n">handler</span> <span class="o">=</span> <span class="n">Updated</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">handler</span> <span class="o">!=</span> <span class="n">null</span><span class="p">)</span>
        <span class="n">handler</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">counter</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<ul>
<li><p>Event型は参照型であり、一見、Updatedを解除すると、handlerも解除されてしまうように思える。仮にhandlerも解除されてしまえば、意味がないことになる。</p></li>
<li><p>しかし、handlerは解除されない。なぜなら、handlerは immutable
であるから。
ここが参考にできる<a class="reference external" href="https://stackoverflow.com/questions/835274/why-can-a-temporary-variable-stop-the-client-from-removing-event-handler/835301#835301">why-can-a-temporary-variable-stop-the-client-from-removing-event-handler</a></p>
<p>The following code snippet is from book Effective C#,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="n">event</span> <span class="n">AddMessageEventHandler</span> <span class="n">Log</span><span class="p">;</span>

<span class="n">public</span> <span class="n">void</span> <span class="n">AddMsg</span> <span class="p">(</span> <span class="nb">int</span> <span class="n">priority</span><span class="p">,</span> <span class="n">string</span> <span class="n">msg</span> <span class="p">)</span>

<span class="p">{</span>
    <span class="o">//</span> <span class="n">This</span> <span class="n">idiom</span> <span class="n">discussed</span> <span class="n">below</span><span class="o">.</span>
    <span class="n">AddMessageEventHandler</span> <span class="n">l</span> <span class="o">=</span> <span class="n">Log</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">l</span> <span class="o">!=</span> <span class="n">null</span> <span class="p">)</span>
        <span class="n">l</span> <span class="p">(</span> <span class="n">null</span><span class="p">,</span> <span class="n">new</span> <span class="n">LoggerEventArgs</span><span class="p">(</span> <span class="n">priority</span><span class="p">,</span> <span class="n">msg</span> <span class="p">)</span> <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The AddMsg method shows the proper way to raise events. The
temporary variable to reference the log event handler is an
important safeguard against race conditions in multithreaded
programs. Without the copy of the reference, clients could remove
event handlers between the if statement check and the execution of
the event handler. By copying the reference, that can’t happen.</p>
<p>Why can a temporary variable stop the client from removing event
handler? I must be missing something here.</p>
<p class="rubric" id="answer">Answer</p>
<p>It doesn’t stop the client from removing the event handler - it
just means that you’ll call that event handler anyway.</p>
<p>The important bit you may be missing is that delegates are
immutable - when an event handler is removed, the value of Log
will change to be the new delegate or null. That’s okay though,
because by that stage you’re using 1 instead of Log.</p>
</li>
<li><p>イベントに関してpub-subの出材パターンがあるが、、、</p></li>
</ul>
<p>上記よりより良い書き方は、次の通り、</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>public void RaiseUpdates(){
    counter++;
    Updated?.Invoke(this, counter);
}
</pre></div>
</div>
<p>まずはnull演算子?により安全性にイベントを呼び出している。
コンパイラは全てのデリゲートあるいはイベントの定義に対して、タイプセーフInvokeメソッドを生成する。</p>
</li>
<li><p>ボックス化およびボックス化解除を最小限に抑える。
(そのほかの参考：<a class="reference external" href="参考">https://ufcpp.net/study/csharp/rmboxing.html</a></p>
<ul>
<li><p>値型は多態性を持たない型。 一方で.NetではSystem.Object
というすべてのオブジェクトの親である参照型を定義している。</p></li>
<li><p>ギャップをうめるために、ボックス化とボックス化解除を用意している。</p>
<ul class="simple">
<li><p>ボックス化：値型を不定な参照型オブジェクトのメンバとすることで参照型が必要な場面においても値型を利用できる仕組み</p></li>
<li><p>ボックス化解除：ボックス化された値型のコピーを取り出すこと。</p></li>
</ul>
</li>
<li><p>System.Objectやインタフェースを必要とする場面で値型を使用する場合に利用する。常にパフォーマンスを落とす。また、ボックス化（解除）は常にコピーは一時的なコピーを作るため潜在的なバグの温床。</p></li>
<li><p>ボックスはヒープ上に確保される。
ヒープ、スタック、領域についてどこかで整理しておく必要あり。</p></li>
<li><p>ボックスに格納された値型を参照する場合、格納庫された値型のコピーが生成されて返される。ボックスの中身にアクセス（参照）する際は毎回コピーされた新しい値が返される。</p></li>
<li><p>名前のない参照型が作成される。（値型をSystem.Objectbの参照に変換するため）</p></li>
<li><p>例えば、</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="nb">object</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="o">//</span><span class="n">box</span>
<span class="nb">int</span> <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="n">y</span><span class="p">;</span> <span class="o">//</span><span class="n">unbox</span>
</pre></div>
</div>
<p>あるいは、</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Console.WriteLine($&quot;first {firstNumber}$);
</pre></div>
</div>
<p>においては、</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">25</span><span class="p">;</span>
<span class="nb">object</span> <span class="n">o</span><span class="o">=</span><span class="n">j</span><span class="p">;</span>
<span class="n">Console</span><span class="o">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">ToString</span><span class="p">());</span>
</pre></div>
</div>
<p>が起きている。</p>
</li>
<li><p>一般的にヒープ領域確保はスタックと比べると重たい処理である。値型の利点はスタック上に値を置く。（ヒープを使わないことによる性能向上である）
ボックス化を避けるためには 具体的な方をできる限り指定する。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    class Program
{
    static void Main()
    {
        ObjectWriteLine(5);
        IntWriteLine(5);
    }

    static void ObjectWriteLine(object x)
    {
        // object.ToString が呼ばれる
        // 値型に対してはボックス化が必要
        Console.WriteLine(x.ToString());
    }

    static void IntWriteLine(int x)
    {
        // こういう場合は、int.ToString が直接呼ばれる
        // virtual メソッドだからといって、必ず virtual に呼ばれるわけじゃない
        // コンパイルの時点で型が確定してるなら、非 virtual にメソッドを呼ぶ
        Console.WriteLine(x.ToString());
    }
}
</pre></div>
</div>
<p>int.ToString(int側でオーバーライドしたもの）が直接呼ばれるため、ボックス化する必要はない。一方で引数がオブジェクトの時ボックス化が起きる。</p>
</li>
<li><p>もう一つの例：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Console.WriteLine($@&quot;数値 {firstnumber.ToString()}&quot;);
</pre></div>
</div>
<p>あらかじめ文字列インスタンスに変換されている。
暗黙的にSystem.Objectへの変換が行われることを注意するべき。</p>
</li>
<li><p>構造体は値型。これのコレクションはコピーができてしまう。不変な値型を作成するべき。</p></li>
<li><p>ジェネリック型について：</p></li>
</ul>
</li>
<li><p>親クラスの変更に応じる場合のみnew修飾子を使用すること。</p>
<ul>
<li><p>Virtual method: 一つの制約を表すことができる。Virtual
メソッドは派生クラスにおいてその実装が変更されることを期待している。</p></li>
<li><p>非Virtual
methodがnew修飾子によって上書きされないように注意するべき。(派生クラスと基底クラスで振る舞いが変わる）</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="k">class</span> <span class="nc">MyClass</span><span class="p">{</span>
    <span class="n">public</span> <span class="n">void</span> <span class="n">MagicMethod</span><span class="p">(){</span>
        <span class="n">Console</span><span class="o">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s2">&quot;myclass&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">public</span> <span class="k">class</span> <span class="nc">MyOtherClass</span> <span class="p">:</span> <span class="n">MyClass</span><span class="p">{</span>
    <span class="o">//</span><span class="n">MagicMethodをこのクラス用に再定義</span>
    <span class="n">public</span> <span class="n">new</span> <span class="n">void</span> <span class="n">MagicMethod</span><span class="p">(){</span>
        <span class="n">Console</span><span class="o">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s2">&quot;myotherclass&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>一方で、「基本的にVirtual」な設計とは派生クラスにおいて全ての挙動を変更しても構わないということ。</p>
</li>
<li><p>メソッドにnewを使用するべき場面はただ一つ：派生クラスですでに使用済みのメソッド名が、新しいバージョンの親クラスに定義されたメンバと競合した場合。</p>
<p>例えば、BaesWidgetの新しいバージョンに”NormalizeValues”メソッドが新たに追加されていた場合、MyWidgetですでにその名前を使っていたとすると競合起きてしまう。そこで、MyWidgetの関数名を変えるか、それが現実的でない場合は、new演算子でリダイレクトする。
長期運用シナリオを考えた場合は、やはり名前を変えた方が良い。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="k">class</span> <span class="nc">MyWidget</span><span class="p">:</span> <span class="n">BaseWidget</span><span class="p">{</span>
    <span class="n">public</span> <span class="n">new</span> <span class="n">void</span> <span class="n">NormalizeValues</span><span class="p">(){</span>
        <span class="o">...</span>
        <span class="n">base</span><span class="o">.</span><span class="n">Normalizevalues</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
</li>
</ol>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">Home</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../theme/chatgpt_papers.html">Topic on GPT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theme/stablediffusion_papers.html">Interesting Papers on Stable Diffusion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theme/zerotoone.html">What important truth do very few people agree with you on?</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../theme/index.html">théma</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../stochasticcalculus/index.html">Stochastic Calculus</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../kit/2020-03-13-arduino-network-lamp.html">Arduino</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Effective C Sharp #6.0, #7.0 まとめ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../excel/index.html">Excel Tips</a></li>
<li class="toctree-l1"><a class="reference internal" href="../softwareengineering/index.html">Software Engineering</a></li>
<li class="toctree-l1"><a class="reference internal" href="../MLApp/index.html">Machine Learning</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../securitiestradelifecycle/index.html">Securities Trade Lifecycle</a></li>
<li class="toctree-l1"><a class="reference internal" href="../deephedge/index.html">Deep Hedge</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../neuroscience/index.html">Neuroscience</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Tips/index.html">Tips</a></li>
<li class="toctree-l1"><a class="reference internal" href="../excel/index.html">Excel Tips</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Effective C Sharp #6.0, #7.0 まとめ</a><ul>
      <li>Previous: <a href="index.html" title="previous chapter">Effective C Sharp #6.0, #7.0 まとめ</a></li>
      <li>Next: <a href="../excel/index.html" title="next chapter">Excel Tips</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, ntaka19.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.4.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/src/effectivecsharp/part1.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>